- module_defaults:
    group/aws:
        region: "{{ aws_region }}"
        aws_access_key: "{{ aws_access_key }}"
        aws_secret_key: "{{ aws_secret_key }}"
        security_token: "{{ security_token | default(omit) }}"
  collections:
    - amazon.aws

  block:
    # ============================================================
    #   PREPARATION
    #
    # Get some information about who we are before starting our tests
    # we'll need this as soon as we start working on the policies
    - name: get ARN of calling user
      aws_caller_info:
      register: aws_caller_info

    # IAM Roles completes before the Role is fully instantiated, create it here
    # to ensure it exists when we need it for updating the policies
    - name: create an IAM role that can do nothing
      iam_role:
        name: '{{ kms_key_alias }}'
        state: present
        assume_role_policy_document: '{"Version": "2012-10-17", "Statement": {"Action": "sts:AssumeRole", "Principal": {"Service": "ec2.amazonaws.com"}, "Effect": "Deny"} }'
      register: iam_role_result

    # ============================================================
    #   TESTS
    # Note - there are waits placed after each action to account for inconsistencies in what
    #        is being returned when fetching key metadata.
    # Combinations of manual waiters, checking expecting key values to actual key value, and static sleeps
    #        have all been tried, but none of those available options have solved the problem.

    - name: See whether key exists and its current state
      aws_kms_info:
        alias: '{{ kms_key_alias }}'

    - name: create a key - check mode
      aws_kms:
        alias: '{{ kms_key_alias }}-check'
        tags:
          Hello: World
        state: present
        enabled: yes
      register: create_kms_check
      check_mode: yes

    - name: find facts about the check mode key
      aws_kms_info:
        alias: '{{ kms_key_alias }}-check'
      register: check_key

    - name: ensure that check mode worked as expected
      assert:
        that:
          - check_key.kms_keys | length == 0
          - create_kms_check is changed

    - name: create a key
      aws_kms:
        alias: '{{ kms_key_alias }}'
        tags:
          Hello: World
        state: present
        enabled: yes
        enable_key_rotation: no
      register: create_kms

    - name: assert that state is enabled
      assert:
        that:
          - create_kms is changed
          - '"key_id" in create_kms'
          - create_kms.key_id | length >= 36
          - not create_kms.key_id.startswith("arn:aws")
          - '"key_arn" in create_kms'
          - create_kms.key_arn.endswith(create_kms.key_id)
          - create_kms.key_arn.startswith("arn:aws")
          - create_kms.key_state == "Enabled"
          - create_kms.tags['Hello'] == 'World'
          - create_kms.enable_key_rotation == false
          - create_kms.key_usage == 'ENCRYPT_DECRYPT'
          - create_kms.customer_master_key_spec == 'SYMMETRIC_DEFAULT'

    - name: Sleep to wait for updates to propagate
      wait_for:
        timeout: 10

    - name: create a key (idempotence) - check mode
      aws_kms:
        alias: '{{ kms_key_alias }}'
        tags:
          Hello: World
        state: present
        enabled: yes
      register: create_kms
      check_mode: yes

    - assert:
        that:
          - create_kms is not changed

    - name: create a key (idempotence)
      aws_kms:
        alias: '{{ kms_key_alias }}'
        tags:
          Hello: World
        state: present
        enabled: yes
      register: create_kms
      check_mode: yes

    - assert:
        that:
          - create_kms is not changed
          - '"key_id" in create_kms'
          - create_kms.key_id | length >= 36
          - not create_kms.key_id.startswith("arn:aws")
          - '"key_arn" in create_kms'
          - create_kms.key_arn.endswith(create_kms.key_id)
          - create_kms.key_arn.startswith("arn:aws")
          - create_kms.key_state == "Enabled"
          - create_kms.tags['Hello'] == 'World'
          - create_kms.enable_key_rotation == false
          - create_kms.key_usage == 'ENCRYPT_DECRYPT'
          - create_kms.customer_master_key_spec == 'SYMMETRIC_DEFAULT'

    # ------------------------------------------------------------------------------------------

    - name: Save IDs for later
      set_fact:
        kms_key_id: '{{ create_kms.key_id }}'
        kms_key_arn: '{{ create_kms.key_arn }}'

    - name: Enable key rotation - check mode
      aws_kms:
        alias: '{{ kms_key_alias }}'
        tags:
          Hello: World
        state: present
        enabled: yes
        enable_key_rotation: yes
      register: create_kms
      check_mode: yes

    - assert:
        that:
          - create_kms.changed

    - name: Enable key rotation
      aws_kms:
        alias: '{{ kms_key_alias }}'
        tags:
          Hello: World
        state: present
        enabled: yes
        enable_key_rotation: yes
      register: create_kms

    - name: assert that key rotation is enabled
      assert:
        that:
          - create_kms.changed
          - create_kms.key_state == "Enabled"
          - create_kms.tags['Hello'] == 'World'
          - create_kms.enable_key_rotation == true

    - name: Sleep to wait for updates to propagate
      wait_for:
        timeout: 10

    - name: Enable key rotation (idempotence) - check mode
      aws_kms:
        alias: '{{ kms_key_alias }}'
        tags:
          Hello: World
        state: present
        enabled: yes
        enable_key_rotation: yes
      register: create_kms
      check_mode: yes

    - assert:
        that:
          - not create_kms.changed

    - name: Enable key rotation (idempotence)
      aws_kms:
        alias: '{{ kms_key_alias }}'
        tags:
          Hello: World
        state: present
        enabled: yes
        enable_key_rotation: yes
      register: create_kms

    - assert:
        that:
          - not create_kms.changed
          - create_kms.key_state == "Enabled"
          - create_kms.tags['Hello'] == 'World'
          - create_kms.enable_key_rotation == true

    # ------------------------------------------------------------------------------------------

    - name: find facts about the key (by ID)
      aws_kms_info:
        key_id: '{{ kms_key_id }}'
      register: new_key

    - name: check that a key was found
      assert:
        that:
          - new_key.kms_keys | length == 1
          - new_key.kms_keys[0].enable_key_rotation == true
          - new_key.kms_keys[0].key_state != "PendingDeletion"

    - name: Update policy - check mode
      aws_kms:
        key_id: '{{ kms_key_id }}'
        policy: "{{ lookup('template', 'console-policy.j2') }}"
      register: kms_policy_changed
      check_mode: yes

    - assert:
        that:
          - kms_policy_changed is changed

    - name: Update policy
      aws_kms:
        key_id: '{{ kms_key_id }}'
        policy: "{{ lookup('template', 'console-policy.j2') }}"
      register: kms_policy_changed

    - name: Policy should have been changed
      assert:
        that:
          - kms_policy_changed is changed

    - name: Sleep to wait for updates to propagate
      wait_for:
        timeout: 10

    - name: Update policy (idempotence) - check mode
      aws_kms:
        alias: "alias/{{ kms_key_alias }}"
        policy: "{{ lookup('template', 'console-policy.j2') }}"
      register: kms_policy_changed
      check_mode: yes

    - assert:
        that:
          - not kms_policy_changed.changed

    - name: Update policy (idempotence)
      aws_kms:
        alias: "alias/{{ kms_key_alias }}"
        policy: "{{ lookup('template', 'console-policy.j2') }}"
      register: kms_policy_changed

    - assert:
        that:
          - not kms_policy_changed.changed

    # ------------------------------------------------------------------------------------------

    - name: grant user-style access to production secrets
      aws_kms:
        mode: grant
        alias: "alias/{{ kms_key_alias }}"
        role_name: '{{ kms_key_alias }}'
        grant_types: "role,role grant"
      register: new_key

    - assert:
        that:
          - new_key.changed

    - name: remove access to production secrets from role
      aws_kms:
        mode: deny
        alias: "alias/{{ kms_key_alias }}"
        role_arn: "{{ iam_role_result.iam_role.arn }}"

    - name: Sleep to wait for updates to propagate
      wait_for:
        timeout: 10

    - name: Add grant - check mode
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        purge_grants: yes
        grants:
          - name: test_grant
            grantee_principal: "{{ iam_role_result.iam_role.arn }}"
            retiring_principal: "{{ aws_caller_info.arn }}"
            constraints:
              encryption_context_equals:
                environment: test
                application: testapp
            operations:
              - Decrypt
              - RetireGrant
      register: grant_one
      check_mode: yes

    - name: assert grant would have been added
      assert:
        that:
          - grant_one.changed

    - name: Add grant
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        purge_grants: yes
        grants:
          - name: test_grant
            grantee_principal: "{{ iam_role_result.iam_role.arn }}"
            retiring_principal: "{{ aws_caller_info.arn }}"
            constraints:
              encryption_context_equals:
                environment: test
                application: testapp
            operations:
              - Decrypt
              - RetireGrant
      register: grant_one

    - name: assert grant added
      assert:
        that:
          - grant_one.changed
          - grant_one.grants | length == 1

    - name: Sleep to wait for updates to propagate
      wait_for:
        timeout: 10

    - name: Add grant (idempotence) - check mode
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        purge_grants: yes
        grants:
          - name: test_grant
            grantee_principal: "{{ iam_role_result.iam_role.arn }}"
            retiring_principal: "{{ aws_caller_info.arn }}"
            constraints:
              encryption_context_equals:
                environment: test
                application: testapp
            operations:
              - Decrypt
              - RetireGrant
      register: grant_one
      check_mode: yes

    - assert:
        that:
          - not grant_one.changed

    - name: Add grant (idempotence)
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        purge_grants: yes
        grants:
          - name: test_grant
            grantee_principal: "{{ iam_role_result.iam_role.arn }}"
            retiring_principal: "{{ aws_caller_info.arn }}"
            constraints:
              encryption_context_equals:
                environment: test
                application: testapp
            operations:
              - Decrypt
              - RetireGrant
      register: grant_one

    - assert:
        that:
          - not grant_one.changed
          - grant_one.grants | length == 1

    - name: Add a second grant
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        grants:
          - name: another_grant
            grantee_principal: "{{ iam_role_result.iam_role.arn }}"
            retiring_principal: "{{ aws_caller_info.arn }}"
            constraints:
              encryption_context_equals:
                Environment: second
                Application: anotherapp
            operations:
              - Decrypt
              - RetireGrant
      register: grant_two

    - name: Assert grant added
      assert:
        that:
          - grant_two.changed
          - grant_two.grants|length == 2

    - name: Sleep to wait for updates to propagate
      wait_for:
        timeout: 10

    - name: Add a second grant again
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        grants:
          - name: another_grant
            grantee_principal: "{{ iam_role_result.iam_role.arn }}"
            retiring_principal: "{{ aws_caller_info.arn }}"
            constraints:
              encryption_context_equals:
                Environment: second
                Application: anotherapp
            operations:
              - Decrypt
              - RetireGrant
      register: grant_two_again

    - name: Assert grant added
      assert:
        that:
          - not grant_two_again.changed
          - grant_two_again.grants|length == 2

    - name: Update the grants with purge_grants set
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        purge_grants: yes
        grants:
          - name: third_grant
            grantee_principal: "{{ iam_role_result.iam_role.arn }}"
            retiring_principal: "{{ aws_caller_info.arn }}"
            constraints:
              encryption_context_equals:
                environment: third
                application: onemoreapp
            operations:
              - Decrypt
              - RetireGrant
      register: grant_three

    - name: Assert grants replaced
      assert:
        that:
          - grant_three.changed
          - grant_three.grants | length == 1

    - name: Update third grant to change encryption context equals to subset
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        grants:
          - name: third_grant
            grantee_principal: "{{ iam_role_result.iam_role.arn }}"
            retiring_principal: "{{ aws_caller_info.arn }}"
            constraints:
              encryption_context_subset:
                environment: third
                application: onemoreapp
            operations:
              - Decrypt
              - RetireGrant
      register: grant_three_update

    - name: Assert grants replaced
      assert:
        that:
          - grant_three_update.changed
          - grant_three_update.grants | length == 1
          - "'encryption_context_equals' not in grant_three_update.grants[0].constraints"
          - "'encryption_context_subset' in grant_three_update.grants[0].constraints"

    # ------------------------------------------------------------------------------------------

    - name: Tag encryption key
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        tags:
          tag_one: tag_one
          tag_two: tag_two
      register: tag_kms

    - name: Assert tags added and grants remain in place
      assert:
        that:
          - tag_kms.changed
          - tag_kms.grants | length == 1
          - "'tag_one' in tag_kms.tags"
          - "'tag_two' in tag_kms.tags"

    - name: Modify tags - check mode
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        purge_tags: yes
        tags:
          tag_two: tag_two_updated
          Tag Three: '{{ resource_prefix }}'
      register: key
      check_mode: yes

    - assert:
        that:
          - key.changed

    - name: Modify tags
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        purge_tags: yes
        tags:
          tag_two: tag_two_updated
          Tag Three: '{{ resource_prefix }}'
      register: key

    - name: Assert tags correctly changed
      assert:
        that:
          - key.changed
          - "'tag_one' not in key.tags"
          - "'tag_two' in key.tags"
          - "key.tags.tag_two == 'tag_two_updated'"
          - "'Tag Three' in key.tags"
          - "key.tags['Tag Three'] == resource_prefix"

    - name: Sleep to wait for updates to propagate
      wait_for:
        timeout: 10

    - name: Modify tags (idempotence) - check mode
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        purge_tags: yes
        tags:
          tag_two: tag_two_updated
          Tag Three: '{{ resource_prefix }}'
      register: key
      check_mode: yes

    - assert:
        that:
          - not key.changed

    - name: Modify tags (idempotence)
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        purge_tags: yes
        tags:
          tag_two: tag_two_updated
          Tag Three: '{{ resource_prefix }}'
      register: key

    - assert:
        that:
          - not key.changed
          - "'tag_one' not in key.tags"
          - "'tag_two' in key.tags"
          - "key.tags.tag_two == 'tag_two_updated'"
          - "'Tag Three' in key.tags"
          - "key.tags['Tag Three'] == resource_prefix"

    # ------------------------------------------------------------------------------------------

    - name: Update description - check mode
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        description: test key for testing
      register: key
      check_mode: yes

    - assert:
        that:
          - key.changed

    - name: Update description
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        description: test key for testing
      register: key

    - assert:
        that:
          - key.changed
          - key.description == "test key for testing"
          - "'tag_one' not in key.tags"
          - "'tag_two' in key.tags"
          - "key.tags.tag_two == 'tag_two_updated'"
          - "'Tag Three' in key.tags"
          - "key.tags['Tag Three'] == resource_prefix"

    - name: Sleep to wait for updates to propagate
      wait_for:
        timeout: 10

    - name: Update description (idempotence) - check mode
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        description: test key for testing
      register: key
      check_mode: yes

    - assert:
        that:
          - not key.changed

    - name: Update description (idempotence)
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        description: test key for testing
      register: key

    - assert:
        that:
          - not key.changed
          - key.description == "test key for testing"
          - "'tag_one' not in key.tags"
          - "'tag_two' in key.tags"
          - "key.tags.tag_two == 'tag_two_updated'"
          - "'Tag Three' in key.tags"
          - "key.tags['Tag Three'] == resource_prefix"

    # ------------------------------------------------------------------------------------------

    - name: Disable key - check mode
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        description: test key for testing
        enabled: no
      register: key
      check_mode: yes

    - assert:
        that:
          - key.changed

    - name: Disable key
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        description: test key for testing
        enabled: no
      register: key

    - name: assert that state is disabled
      assert:
        that:
          - key.changed
          - key.key_state == "Disabled"
          - not key.enabled

    - name: Sleep to wait for updates to propagate
      wait_for:
        timeout: 10

    - name: Disable key (idempotence) - check mode
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        description: test key for testing
        enabled: no
      register: key
      check_mode: yes

    - assert:
        that:
          - not key.changed

    - name: Disable key (idempotence)
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
        description: test key for testing
        enabled: no
      register: key

    - assert:
        that:
          - not key.changed
          - key.key_state == "Disabled"
          - not key.enabled

    # ------------------------------------------------------------------------------------------

    - name: update policy to remove access to key rotation status
      aws_kms:
        alias: 'alias/{{ kms_key_alias }}'
        policy: "{{ lookup('template', 'console-policy-no-key-rotation.j2') }}"
      register: key

    - assert:
        that:
          - key.changed
          - key.key_state == "Enabled"
          - key.enable_key_rotation is none

    - name: Sleep to wait for updates to propagate
      wait_for:
        timeout: 10

    - name: Perform a search for key by tag
      aws_kms_info:
        filters:
          "tag:Tag Three": "{{ resource_prefix }}"
      register: info_tag_filtered

    - name: Verify all expected attributes
      vars:
        tagged_key: '{{ info_tag_filtered.kms_keys[0] }}'
      assert:
        that:
          - info_tag_filtered.kms_keys | length == 1
          - "'aliases' in tagged_key"
          - kms_key_alias in tagged_key.aliases
          - "'aws_account_id' in tagged_key"
          - tagged_key.aws_account_id == aws_caller_info.account
          - "'creation_date' in tagged_key"
          - "'customer_master_key_spec' in tagged_key"
          - tagged_key.customer_master_key_spec == 'SYMMETRIC_DEFAULT'
          - "'description' in tagged_key"
          - tagged_key.description == 'test key for testing'
          - "'enable_key_rotation' in tagged_key"
          - tagged_key.enable_key_rotation is none
          - "'enabled' in tagged_key"
          - tagged_key.enabled
          - "'encryption_algorithms' in tagged_key"
          - "'SYMMETRIC_DEFAULT' in tagged_key.encryption_algorithms"
          - "'grants' in tagged_key"
          - "'key_arn' in tagged_key"
          - tagged_key.key_arn == kms_key_arn
          - "'key_id' in tagged_key"
          - tagged_key.key_id == kms_key_id
          - "'key_manager' in tagged_key"
          - tagged_key.key_manager == 'CUSTOMER'
          - "'key_state' in tagged_key"
          - tagged_key.key_state == 'Enabled'
          - "'key_usage' in tagged_key"
          - tagged_key.key_usage == 'ENCRYPT_DECRYPT'
          - "'origin' in tagged_key"
          - tagged_key.origin == "AWS_KMS"
          - "'policies' in tagged_key"
          - tagged_key.policies | length == 1
          - "'tags' in tagged_key"
          - "'Tag Three' in tagged_key.tags"
          - tagged_key.tags['Tag Three'] == resource_prefix
          - "'tag_two' in tagged_key.tags"
          - tagged_key.tags['tag_two'] == 'tag_two_updated'

    # ------------------------------------------------------------------------------------------

    - name: Delete key - check mode
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: absent
      register: key
      check_mode: yes

    - assert:
        that:
          - key is changed

    - name: Delete key
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: absent
      register: key

    - name: Sleep to wait for updates to propagate
      wait_for:
        timeout: 10

    - name: Assert that state is pending deletion
      vars:
        now_time: '{{ lookup("pipe", "date -u +%Y-%m-%d\ %H:%M:%S") }}'
        deletion_time: '{{ key.deletion_date[:19] | to_datetime("%Y-%m-%dT%H:%M:%S") }}'
      assert:
        that:
          - key.key_state == "PendingDeletion"
          - key.changed
          # Times won't be perfect, allow a 24 hour window
          - (( deletion_time | to_datetime ) - ( now_time | to_datetime )).days <= 30
          - (( deletion_time | to_datetime ) - ( now_time | to_datetime )).days >= 29

    - name: Delete key (idempotence) - check mode
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: absent
      register: key
      check_mode: yes

    - assert:
        that:
          - not key.changed

    - name: Delete key (idempotence)
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: absent
      register: key

    - assert:
        that:
          - not key.changed
          - key.key_state == "PendingDeletion"

    # ------------------------------------------------------------------------------------------

    - name: Cancel key deletion - check mode
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
      register: key
      check_mode: yes

    - assert:
        that:
          - key.changed

    - name: Cancel key deletion
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
      register: key

    - assert:
        that:
          - key.changed
          - key.key_state != "PendingDeletion"

    - name: Sleep to wait for updates to propagate
      wait_for:
        timeout: 10

    - name: Cancel key deletion (idempotence) - check mode
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
      register: key
      check_mode: yes

    - assert:
        that:
          - not key.changed

    - name: Cancel key deletion (idempotence)
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: present
      register: key

    - assert:
        that:
          - not key.changed
          - key.key_state != "PendingDeletion"

    # ------------------------------------------------------------------------------------------

    - name: delete the key with a specific deletion window
      aws_kms:
        alias: '{{ kms_key_alias }}'
        state: absent
        pending_window: 7
      register: delete_kms

    - name: assert that state is pending deletion
      vars:
        now_time: '{{ lookup("pipe", "date -u +%Y-%m-%d\ %H:%M:%S") }}'
        deletion_time: '{{ delete_kms.deletion_date[:19] | to_datetime("%Y-%m-%dT%H:%M:%S") }}'
      assert:
        that:
          - delete_kms.key_state == "PendingDeletion"
          - delete_kms.changed
          # Times won't be perfect, allow a 24 hour window
          - (( deletion_time | to_datetime ) - ( now_time | to_datetime )).days <= 7
          - (( deletion_time | to_datetime ) - ( now_time | to_datetime )).days >= 6

    # ============================================================
    # test different key usage and specs
    - name: create kms key with different specs
      aws_kms:
        alias: '{{ kms_key_alias }}-diff-spec-usage'
        purge_grants: yes
        key_spec: ECC_NIST_P256
        key_usage: SIGN_VERIFY
      register: create_diff_kms

    - name: verify different specs on kms key
      assert:
        that:
          - '"key_id" in create_diff_kms'
          - create_diff_kms.key_id | length >= 36
          - not create_diff_kms.key_id.startswith("arn:aws")
          - '"key_arn" in create_diff_kms'
          - create_diff_kms.key_arn.endswith(create_diff_kms.key_id)
          - create_diff_kms.key_arn.startswith("arn:aws")
          - create_diff_kms.key_usage == 'SIGN_VERIFY'
          - create_diff_kms.customer_master_key_spec == 'ECC_NIST_P256'

  always:
    # ============================================================
    #   CLEAN-UP
    - name: finish off by deleting keys
      aws_kms:
        state: absent
        alias: "{{ item }}"
        pending_window: 7
      ignore_errors: True
      loop:
        - "{{ kms_key_alias }}"
        - "{{ kms_key_alias }}-diff-spec-usage"
        - "{{ kms_key_alias }}-check"

    - name: remove the IAM role
      iam_role:
        name: '{{ kms_key_alias }}'
        state: absent
      ignore_errors: True
